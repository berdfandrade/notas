import { rules } from './rules';
export class TitlePageBlock {
    constructor(line) {
        this.tokens = [];
        const match = line.replace(rules.title_page, '\n$1').split(rules.splitter).reverse();
        this.tokens = match.reduce((previous, item) => new TitlePageToken(item).addTo(previous), []);
    }
    addTo(tokens) {
        return [...tokens, ...this.tokens];
    }
    static matchedBy(line) {
        return rules.title_page.test(line);
    }
}
export class TitlePageToken {
    constructor(item) {
        this.is_title = true;
        const pair = item.replace(rules.cleaner, '').split(/\:\n*/);
        this.type = pair[0].trim().toLowerCase().replace(' ', '_');
        this.text = pair[1].trim();
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class SceneHeadingToken {
    constructor(line) {
        this.type = 'scene_heading';
        const match = line.match(rules.scene_heading);
        this.text = match[1] || match[2];
        const meta = this.text.match(rules.scene_number);
        if (meta) {
            this.scene_number = meta[2];
            this.text = this.text.replace(rules.scene_number, '');
        }
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.scene_heading.test(line);
    }
}
export class CenteredToken {
    constructor(line) {
        this.type = 'centered';
        const match = line.match(rules.centered);
        this.text = match[0].replace(/ *[><] */g, '');
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.centered.test(line);
    }
}
export class TransitionToken {
    constructor(line) {
        this.type = 'transition';
        const match = line.match(rules.transition);
        this.text = match[1] || match[2];
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.transition.test(line);
    }
}
export class DialogueBlock {
    constructor(line, dual) {
        this.tokens = [];
        const match = line.match(rules.dialogue);
        let name = match[1];
        // iterating from the bottom up, so push dialogue blocks in reverse order
        const isDualDialogue = !!match[2];
        if (isDualDialogue) {
            this.tokens.push(new DualDialogueEndToken());
        }
        this.tokens.push(new DialogueEndToken());
        const parts = match[3].split(/\n/);
        let dialogue = parts.reduce((p, text = '') => {
            const lastIndex = p.length - 1;
            const previousToken = p[lastIndex];
            if (!text.length) {
                return p;
            }
            if (rules.parenthetical.test(text)) {
                return [...p, new ParentheticalToken(text)];
            }
            if (rules.lyrics.test(text)) {
                if (previousToken.type === 'lyrics') {
                    p[lastIndex].text =
                        `${previousToken.text}\n${text.replace(/^~/, '')}`;
                    return p;
                }
                else {
                    return [...p, new LyricsToken(text)];
                }
            }
            if (previousToken) {
                if (previousToken.type === 'dialogue') {
                    p[lastIndex].text = `${previousToken.text}\n${text}`;
                    return p;
                }
            }
            return [...p, new DialogueToken(text)];
        }, []).reverse();
        this.tokens.push(...dialogue);
        this.tokens.push(new CharacterToken(name.startsWith('@')
            ? name.replace(/^@/, '').trim()
            : name.trim()), new DialogueBeginToken(isDualDialogue ? 'right' : dual ? 'left' : undefined));
        if (dual) {
            this.tokens.push(new DualDialogueBeginToken());
        }
        this.dual = isDualDialogue;
    }
    addTo(tokens) {
        return [...tokens, ...this.tokens];
    }
    static matchedBy(line) {
        return rules.dialogue.test(line);
    }
}
export class DialogueBeginToken {
    constructor(dual) {
        this.type = 'dialogue_begin';
        this.dual = dual;
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class CharacterToken {
    constructor(text) {
        this.type = 'character';
        this.text = text;
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class DialogueToken {
    constructor(text) {
        this.type = 'dialogue';
        this.text = text;
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class DialogueEndToken {
    constructor() {
        this.type = 'dialogue_end';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class ParentheticalToken {
    constructor(text) {
        this.type = 'parenthetical';
        this.text = text;
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class DualDialogueBeginToken {
    constructor() {
        this.type = 'dual_dialogue_begin';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class DualDialogueEndToken {
    constructor() {
        this.type = 'dual_dialogue_end';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
export class LyricsToken {
    constructor(line) {
        this.type = 'lyrics';
        this.text = line.replace(/^~(?! )/gm, '');
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.lyrics.test(line);
    }
}
export class SectionToken {
    constructor(line) {
        this.type = 'section';
        const match = line.match(rules.section);
        this.text = match[2];
        this.depth = match[1].length;
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.section.test(line);
    }
}
export class SynopsisToken {
    constructor(line) {
        this.type = 'synopsis';
        const match = line.match(rules.synopsis);
        this.text = match[1];
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.synopsis.test(line);
    }
}
export class NoteToken {
    constructor(line) {
        this.type = 'note';
        const match = line.match(rules.note);
        this.text = match[1];
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.note.test(line);
    }
}
export class BoneyardToken {
    constructor(line) {
        const match = line.match(rules.boneyard);
        this.type = match[0][0] === '/' ? 'boneyard_begin' : 'boneyard_end';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.boneyard.test(line);
    }
}
export class PageBreakToken {
    constructor() {
        this.type = 'page_break';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.page_break.test(line);
    }
}
export class LineBreakToken {
    constructor() {
        this.type = 'line_break';
    }
    addTo(tokens) {
        return [...tokens, this];
    }
    static matchedBy(line) {
        return rules.line_break.test(line);
    }
}
export class ActionToken {
    constructor(line) {
        this.type = 'action';
        this.text = line.replace(/^!(?! )/gm, '');
    }
    addTo(tokens) {
        return [...tokens, this];
    }
}
//# sourceMappingURL=token.js.map