"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scanner = void 0;
const rules_1 = require("./rules");
const token_1 = require("./token");
const lexer_1 = require("./lexer");
class Scanner {
    tokenize(script) {
        // reverse the array so that dual dialog can be constructed bottom up
        const source = new lexer_1.Lexer().reconstruct(script).split(rules_1.rules.splitter).reverse();
        const tokens = source.reduce((previous, line) => {
            /** title page */
            if (token_1.TitlePageBlock.matchedBy(line)) {
                return new token_1.TitlePageBlock(line).addTo(previous);
            }
            /** scene headings */
            if (token_1.SceneHeadingToken.matchedBy(line)) {
                return new token_1.SceneHeadingToken(line).addTo(previous);
            }
            /** centered */
            if (token_1.CenteredToken.matchedBy(line)) {
                return new token_1.CenteredToken(line).addTo(previous);
            }
            /** transitions */
            if (token_1.TransitionToken.matchedBy(line)) {
                return new token_1.TransitionToken(line).addTo(previous);
            }
            /** dialogue blocks - characters, parentheticals and dialogue */
            if (token_1.DialogueBlock.matchedBy(line)) {
                const dialogueBlock = new token_1.DialogueBlock(line, this.lastLineWasDualDialogue);
                this.lastLineWasDualDialogue = dialogueBlock.dual;
                return dialogueBlock.addTo(previous);
            }
            /** section */
            if (token_1.SectionToken.matchedBy(line)) {
                return new token_1.SectionToken(line).addTo(previous);
            }
            /** synopsis */
            if (token_1.SynopsisToken.matchedBy(line)) {
                return new token_1.SynopsisToken(line).addTo(previous);
            }
            /** notes */
            if (token_1.NoteToken.matchedBy(line)) {
                return new token_1.NoteToken(line).addTo(previous);
            }
            /** boneyard */
            if (token_1.BoneyardToken.matchedBy(line)) {
                return new token_1.BoneyardToken(line).addTo(previous);
            }
            /** lyrics */
            if (token_1.LyricsToken.matchedBy(line)) {
                return new token_1.LyricsToken(line).addTo(previous);
            }
            /** page breaks */
            if (token_1.PageBreakToken.matchedBy(line)) {
                return new token_1.PageBreakToken().addTo(previous);
            }
            /** line breaks */
            if (token_1.LineBreakToken.matchedBy(line)) {
                return new token_1.LineBreakToken().addTo(previous);
            }
            // everything else is action -- remove `!` for forced action
            return new token_1.ActionToken(line).addTo(previous);
        }, []);
        return tokens.reverse();
    }
}
exports.Scanner = Scanner;
//# sourceMappingURL=scanner.js.map